function f(n){return n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function l(n,...t){let e=[];for(let s=0;s<n.length;s++){e.push(f(n[s]));let r=t[s];typeof r=="string"?e.push(f(r)):r instanceof RegExp&&e.push(r.source)}if(!e[0].startsWith("#/"))throw new Error(`Routes must start with "#/"; route is ${e.join("")}`);return new RegExp(`^${e.join("")}$`)}function u(n){return new RegExp(`(?<${n}>\\w+)`)}var o=class{#t=new Map;#s=void 0;#n=void 0;#e=void 0;#r=new AbortController;constructor(t){this.#e=t?.startAt}connect(){return addEventListener("popstate",()=>{this.#i()},{signal:this.#r.signal}),this.#e&&!location.hash?location.hash=this.#e:this.#i(),this}disconnect(){this.#r.abort()}on(t,e){return this.#t.set(t,e),this}off(t){return this.#t.delete(t),this}fallback(t){return this.#s=t,this}afterEach(t){return this.#n=t,this}#i(t=location.hash){let e,s,r,a;for(let[i,c]of this.#t.entries())if(typeof i=="string"&&t===i?s=c:i instanceof RegExp&&(r=t.match(i))&&(a={...r.groups},s=c),s){e=i;break}let h={url:t,params:a??{},route:e};(s??this.#s)?.(h),this.#n?.(h)}};export{o as default,u as param,l as route};
//# sourceMappingURL=lib.js.map
