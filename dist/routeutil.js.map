{
  "version": 3,
  "sources": ["../src/routeutil.js"],
  "sourcesContent": ["//  @ts-check\n\n/* -------------------------------------------------- *\n * Types                                              *\n * -------------------------------------------------- */\n\n/**\n * Defines a route for adding it to the router.\n *\n * @typedef {string | RegExp} RouteDef\n */\n\n/**\n * Contains information about a resolved route.\n *\n * @typedef {object} ResolvedRoute\n * @prop {string} url The raw URL\n * @prop {RouteDef} [route] The matched route. Can be `undefined` if no route\n *  has matched the URL, typically when the fallback is active.\n * @prop {Record<string, string>} params The parameters extracted from the route\n */\n\n/**\n * A callback that is run when a route is matched.\n *\n * @callback RouteHandler\n * @param {ResolvedRoute} resolved The route as the router parsed it\n * @returns {void}\n */\n\n/* -------------------------------------------------- *\n * Utils                                              *\n * -------------------------------------------------- */\n\n/**\n * Escape all regex special characters.\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#escaping\n *\n * @param {string} val\n * @returns Escaped value\n */\nfunction escapeRegex(val) {\n  return val.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n/**\n * Helper to create a regular expression that can be used as a route.\n *\n * @param {TemplateStringsArray} segments\n * @param  {Array<string | RegExp>} values\n * @returns {RegExp}\n */\nexport function route(segments, ...values) {\n  /** @type {string[]} */\n  const buf = [];\n\n  for (let i = 0; i < segments.length; i++) {\n    buf.push(escapeRegex(segments[i]));\n\n    const val = values[i];\n    if (typeof val === \"string\") buf.push(escapeRegex(val));\n    else if (val instanceof RegExp) buf.push(val.source);\n  }\n\n  if (!buf[0].startsWith(\"#/\")) {\n    throw new Error(`Routes must start with \"#/\"; route is ${buf.join(\"\")}`);\n  }\n\n  return new RegExp(`^${buf.join(\"\")}$`);\n}\n\n/**\n * Takes a parameter name and wraps it in a regular expression that can be\n * used for capturing that parameter in a `group`. Parameters created this\n * way will match one or more word characters (i.e. letters, numbers, _).\n *\n * @param {string} name The name of the parameter. Must be unique per route.\n *  Must be a valid name for a named capturing group in a regular expression.\n * @returns {RegExp} The regex of the parameter for use in a `route`\n */\nexport function param(name) {\n  return new RegExp(`(?<${name}>\\\\w+)`);\n}\n\n/* -------------------------------------------------- *\n * Router class                                       *\n * -------------------------------------------------- */\n\nexport default class Router {\n  /** @type {Map<RouteDef, RouteHandler>} */\n  #handlers = new Map();\n\n  /** @type {RouteHandler | undefined} */\n  #fallbackHandler = undefined;\n\n  /** @type {RouteHandler | undefined} */\n  #afterEachHandler = undefined;\n\n  /** @type {string | undefined} */\n  #startAt = undefined;\n\n  #controller = new AbortController();\n\n  /**\n   * @param {object} [opts]\n   * @param {string} [opts.startAt] If set, the router will initially navigate\n   *  to the specified path if the locations' hash is empty when the router\n   *  connects.\n   */\n  constructor(opts) {\n    this.#startAt = opts?.startAt;\n  }\n\n  /**\n   * Performs the initial routing after the routes have been initialized.\n   *\n   * @returns {Router} The router instance for chaining\n   */\n  connect() {\n    addEventListener(\n      \"popstate\",\n      () => {\n        this.#exec();\n      },\n      { signal: this.#controller.signal }\n    );\n\n    if (this.#startAt && !location.hash) location.hash = this.#startAt;\n    else this.#exec();\n\n    return this;\n  }\n\n  /**\n   * Stops route handling. Note that it cannot be restarted, you will need to\n   * create a new router if you need it again.\n   */\n  disconnect() {\n    this.#controller.abort();\n  }\n\n  /**\n   * Adds a new route handler. If an identical handler already exists, the\n   * existing handler is replaced.\n   *\n   * @param {RouteDef | RouteDef[]} route Path of the route\n   * @param {RouteHandler} handler Function to be called when the route is matched\n   * @returns {Router} The router instance for chaining\n   */\n  on(route, handler) {\n    const routeArr = Array.isArray(route) ? route : [route];\n    routeArr.forEach((i) => this.#handlers.set(i, handler));\n    return this;\n  }\n\n  /**\n   * Removes an existing route handler.\n   *\n   * @param {RouteDef | RouteDef[]} route\n   * @returns {Router} The router instance for chaining\n   */\n  off(route) {\n    const routeArr = Array.isArray(route) ? route : [route];\n    routeArr.forEach((i) => this.#handlers.delete(i));\n    return this;\n  }\n\n  /**\n   * This handler will be called if no route matches.\n   *\n   * @param {RouteHandler} handler\n   * @returns {Router} The router instance for chaining\n   */\n  fallback(handler) {\n    this.#fallbackHandler = handler;\n    return this;\n  }\n\n  /**\n   * This handler will be called after any navigation (including when no route\n   * matched).\n   *\n   * @param {RouteHandler} handler\n   * @returns {Router} The router instance for chaining\n   */\n  afterEach(handler) {\n    this.#afterEachHandler = handler;\n    return this;\n  }\n\n  /**\n   * Parses the URL to a route and runs handler associated with the route.\n   *\n   * @param {string} [url] The new URL. Defaults to `location.hash`.\n   */\n  #exec(url = location.hash) {\n    let route, handler, match, params;\n\n    for (const [k, v] of this.#handlers.entries()) {\n      if (typeof k === \"string\" && url === k) {\n        handler = v;\n      } else if (k instanceof RegExp && (match = url.match(k))) {\n        params = { ...match.groups };\n        handler = v;\n      }\n\n      if (handler) {\n        route = k;\n        break;\n      }\n    }\n\n    /** @type {ResolvedRoute} */\n    const resolved = { url, params: params ?? {}, route };\n\n    (handler ?? this.#fallbackHandler)?.(resolved);\n    this.#afterEachHandler?.(resolved);\n  }\n}\n"],
  "mappings": "AAyCA,SAASA,EAAYC,EAAK,CACxB,OAAOA,EAAI,QAAQ,sBAAuB,MAAM,CAClD,CASO,SAASC,EAAMC,KAAaC,EAAQ,CAEzC,IAAMC,EAAM,CAAC,EAEb,QAASC,EAAI,EAAGA,EAAIH,EAAS,OAAQG,IAAK,CACxCD,EAAI,KAAKL,EAAYG,EAASG,CAAC,CAAC,CAAC,EAEjC,IAAML,EAAMG,EAAOE,CAAC,EAChB,OAAOL,GAAQ,SAAUI,EAAI,KAAKL,EAAYC,CAAG,CAAC,EAC7CA,aAAe,QAAQI,EAAI,KAAKJ,EAAI,MAAM,CACrD,CAEA,GAAI,CAACI,EAAI,CAAC,EAAE,WAAW,IAAI,EACzB,MAAM,IAAI,MAAM,yCAAyCA,EAAI,KAAK,EAAE,CAAC,EAAE,EAGzE,OAAO,IAAI,OAAO,IAAIA,EAAI,KAAK,EAAE,CAAC,GAAG,CACvC,CAWO,SAASE,EAAMC,EAAM,CAC1B,OAAO,IAAI,OAAO,MAAMA,CAAI,QAAQ,CACtC,CAMA,IAAqBC,EAArB,KAA4B,CAE1BC,GAAY,IAAI,IAGhBC,GAAmB,OAGnBC,GAAoB,OAGpBC,GAAW,OAEXC,GAAc,IAAI,gBAQlB,YAAYC,EAAM,CAChB,KAAKF,GAAWE,GAAM,OACxB,CAOA,SAAU,CACR,wBACE,WACA,IAAM,CACJ,KAAKC,GAAM,CACb,EACA,CAAE,OAAQ,KAAKF,GAAY,MAAO,CACpC,EAEI,KAAKD,IAAY,CAAC,SAAS,KAAM,SAAS,KAAO,KAAKA,GACrD,KAAKG,GAAM,EAET,IACT,CAMA,YAAa,CACX,KAAKF,GAAY,MAAM,CACzB,CAUA,GAAGZ,EAAOe,EAAS,CAEjB,OADiB,MAAM,QAAQf,CAAK,EAAIA,EAAQ,CAACA,CAAK,GAC7C,QAASI,GAAM,KAAKI,GAAU,IAAIJ,EAAGW,CAAO,CAAC,EAC/C,IACT,CAQA,IAAIf,EAAO,CAET,OADiB,MAAM,QAAQA,CAAK,EAAIA,EAAQ,CAACA,CAAK,GAC7C,QAASI,GAAM,KAAKI,GAAU,OAAOJ,CAAC,CAAC,EACzC,IACT,CAQA,SAASW,EAAS,CAChB,YAAKN,GAAmBM,EACjB,IACT,CASA,UAAUA,EAAS,CACjB,YAAKL,GAAoBK,EAClB,IACT,CAOAD,GAAME,EAAM,SAAS,KAAM,CACzB,IAAIhB,EAAOe,EAASE,EAAOC,EAE3B,OAAW,CAACC,EAAGC,CAAC,IAAK,KAAKZ,GAAU,QAAQ,EAQ1C,GAPI,OAAOW,GAAM,UAAYH,IAAQG,EACnCJ,EAAUK,EACDD,aAAa,SAAWF,EAAQD,EAAI,MAAMG,CAAC,KACpDD,EAAS,CAAE,GAAGD,EAAM,MAAO,EAC3BF,EAAUK,GAGRL,EAAS,CACXf,EAAQmB,EACR,KACF,CAIF,IAAME,EAAW,CAAE,IAAAL,EAAK,OAAQE,GAAU,CAAC,EAAG,MAAAlB,CAAM,GAEnDe,GAAW,KAAKN,MAAoBY,CAAQ,EAC7C,KAAKX,KAAoBW,CAAQ,CACnC,CACF",
  "names": ["escapeRegex", "val", "route", "segments", "values", "buf", "i", "param", "name", "Router", "#handlers", "#fallbackHandler", "#afterEachHandler", "#startAt", "#controller", "opts", "#exec", "handler", "url", "match", "params", "k", "v", "resolved"]
}
